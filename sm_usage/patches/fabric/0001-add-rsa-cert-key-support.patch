From 697e2d277827bb8d25497d29cb26790e8bcdd0e0 Mon Sep 17 00:00:00 2001
From: fengjianjian <fengjj@7zhilu.com>
Date: Wed, 2 Jan 2019 08:31:10 +0800
Subject: [PATCH 1/4] add rsa cert&key support

---
 bccsp/sw/rsa.go                         | 11 ++++---
 common/tools/cryptogen/ca/ca_test.go    |  4 +--
 common/tools/cryptogen/ca/generator.go  |  9 +++---
 common/tools/cryptogen/csp/csp.go       | 14 +++++----
 common/tools/cryptogen/csp/csp_test.go  |  6 ++--
 common/tools/cryptogen/main.go          | 40 +++++++++++++++----------
 common/tools/cryptogen/msp/generator.go | 10 +++----
 common/tools/cryptogen/msp/msp_test.go  | 24 +++++++--------
 8 files changed, 66 insertions(+), 52 deletions(-)

diff --git a/bccsp/sw/rsa.go b/bccsp/sw/rsa.go
index 375990d33..346a699c9 100644
--- a/bccsp/sw/rsa.go
+++ b/bccsp/sw/rsa.go
@@ -19,17 +19,18 @@ package sw
 import (
 	"crypto/rand"
 	"crypto/rsa"
-	"errors"
 	"fmt"
 
 	"github.com/hyperledger/fabric/bccsp"
+	"crypto"
 )
 
 type rsaSigner struct{}
 
 func (s *rsaSigner) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) ([]byte, error) {
 	if opts == nil {
-		return nil, errors.New("Invalid options. Must be different from nil.")
+		opts=&rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: crypto.SHA256}
+		//return nil, errors.New("Invalid options. Must be different from nil.")
 	}
 
 	return k.(*rsaPrivateKey).privKey.Sign(rand.Reader, digest, opts)
@@ -39,7 +40,8 @@ type rsaPrivateKeyVerifier struct{}
 
 func (v *rsaPrivateKeyVerifier) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (bool, error) {
 	if opts == nil {
-		return false, errors.New("Invalid options. It must not be nil.")
+		opts=&rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: crypto.SHA256}
+		//return nil, errors.New("Invalid options. Must be different from nil.")
 	}
 	switch opts.(type) {
 	case *rsa.PSSOptions:
@@ -57,7 +59,8 @@ type rsaPublicKeyKeyVerifier struct{}
 
 func (v *rsaPublicKeyKeyVerifier) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (bool, error) {
 	if opts == nil {
-		return false, errors.New("Invalid options. It must not be nil.")
+		opts=&rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: crypto.SHA256}
+		//return nil, errors.New("Invalid options. Must be different from nil.")
 	}
 	switch opts.(type) {
 	case *rsa.PSSOptions:
diff --git a/common/tools/cryptogen/ca/ca_test.go b/common/tools/cryptogen/ca/ca_test.go
index 95fc39baa..b3a532096 100644
--- a/common/tools/cryptogen/ca/ca_test.go
+++ b/common/tools/cryptogen/ca/ca_test.go
@@ -40,7 +40,7 @@ func TestLoadCertificateECDSA(t *testing.T) {
 	caDir := filepath.Join(testDir, "ca")
 	certDir := filepath.Join(testDir, "certs")
 	// generate private key
-	priv, _, err := csp.GeneratePrivateKey(certDir)
+	priv, _, err := csp.GeneratePrivateKey(certDir, "")
 	assert.NoError(t, err, "Failed to generate signed certificate")
 
 	// get EC public key
@@ -106,7 +106,7 @@ func TestGenerateSignCertificate(t *testing.T) {
 	caDir := filepath.Join(testDir, "ca")
 	certDir := filepath.Join(testDir, "certs")
 	// generate private key
-	priv, _, err := csp.GeneratePrivateKey(certDir)
+	priv, _, err := csp.GeneratePrivateKey(certDir, "")
 	assert.NoError(t, err, "Failed to generate signed certificate")
 
 	// get EC public key
diff --git a/common/tools/cryptogen/ca/generator.go b/common/tools/cryptogen/ca/generator.go
index 7651ac453..797399c2e 100644
--- a/common/tools/cryptogen/ca/generator.go
+++ b/common/tools/cryptogen/ca/generator.go
@@ -7,7 +7,6 @@ package ca
 
 import (
 	"crypto"
-	"crypto/ecdsa"
 	"crypto/rand"
 	"crypto/x509"
 	"crypto/x509/pkix"
@@ -39,14 +38,14 @@ type CA struct {
 
 // NewCA creates an instance of CA and saves the signing key pair in
 // baseDir/name
-func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddress, postalCode string) (*CA, error) {
+func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddress, postalCode string, algo string) (*CA, error) {
 
 	var response error
 	var ca *CA
 
 	err := os.MkdirAll(baseDir, 0755)
 	if err == nil {
-		priv, signer, err := csp.GeneratePrivateKey(baseDir)
+		priv, signer, err := csp.GeneratePrivateKey(baseDir, algo)
 		response = err
 		if err == nil {
 			// get public signing certificate
@@ -96,7 +95,7 @@ func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddre
 
 // SignCertificate creates a signed certificate based on a built-in template
 // and saves it in baseDir/name
-func (ca *CA) SignCertificate(baseDir, name string, ous, sans []string, pub *ecdsa.PublicKey,
+func (ca *CA) SignCertificate(baseDir, name string, ous, sans []string, pub interface{},
 	ku x509.KeyUsage, eku []x509.ExtKeyUsage) (*x509.Certificate, error) {
 
 	template := x509Template()
@@ -188,7 +187,7 @@ func x509Template() x509.Certificate {
 }
 
 // generate a signed X509 certificate using ECDSA
-func genCertificateECDSA(baseDir, name string, template, parent *x509.Certificate, pub *ecdsa.PublicKey,
+func genCertificateECDSA(baseDir, name string, template, parent *x509.Certificate, pub interface{},
 	priv interface{}) (*x509.Certificate, error) {
 
 	//create the x509 public cert
diff --git a/common/tools/cryptogen/csp/csp.go b/common/tools/cryptogen/csp/csp.go
index 40cfaea00..0e9dc6ed7 100644
--- a/common/tools/cryptogen/csp/csp.go
+++ b/common/tools/cryptogen/csp/csp.go
@@ -7,7 +7,6 @@ package csp
 
 import (
 	"crypto"
-	"crypto/ecdsa"
 	"crypto/x509"
 	"encoding/pem"
 	"io/ioutil"
@@ -79,7 +78,7 @@ func LoadPrivateKey(keystorePath string) (bccsp.Key, crypto.Signer, error) {
 }
 
 // GeneratePrivateKey creates a private key and stores it in keystorePath
-func GeneratePrivateKey(keystorePath string) (bccsp.Key,
+func GeneratePrivateKey(keystorePath string, algo string) (bccsp.Key,
 	crypto.Signer, error) {
 
 	var err error
@@ -100,7 +99,12 @@ func GeneratePrivateKey(keystorePath string) (bccsp.Key,
 	csp, err := factory.GetBCCSPFromOpts(opts)
 	if err == nil {
 		// generate a key
-		priv, err = csp.KeyGen(&bccsp.ECDSAP256KeyGenOpts{Temporary: false})
+		var opt bccsp.KeyGenOpts
+		opt = &bccsp.ECDSAP256KeyGenOpts{Temporary: false}
+		if strings.ToUpper(algo) == bccsp.RSA {
+			opt = &bccsp.RSAKeyGenOpts{Temporary: false}
+		}
+		priv, err = csp.KeyGen(opt)
 		if err == nil {
 			// create a crypto.Signer
 			s, err = signer.New(csp, priv)
@@ -109,7 +113,7 @@ func GeneratePrivateKey(keystorePath string) (bccsp.Key,
 	return priv, s, err
 }
 
-func GetECPublicKey(priv bccsp.Key) (*ecdsa.PublicKey, error) {
+func GetECPublicKey(priv bccsp.Key) (interface{}, error) {
 
 	// get the public key
 	pubKey, err := priv.PublicKey()
@@ -126,5 +130,5 @@ func GetECPublicKey(priv bccsp.Key) (*ecdsa.PublicKey, error) {
 	if err != nil {
 		return nil, err
 	}
-	return ecPubKey.(*ecdsa.PublicKey), nil
+	return ecPubKey, nil
 }
diff --git a/common/tools/cryptogen/csp/csp_test.go b/common/tools/cryptogen/csp/csp_test.go
index f2210e1b8..7ce142c93 100644
--- a/common/tools/cryptogen/csp/csp_test.go
+++ b/common/tools/cryptogen/csp/csp_test.go
@@ -48,7 +48,7 @@ func (mk *mockKey) Private() bool { return false }
 var testDir = filepath.Join(os.TempDir(), "csp-test")
 
 func TestLoadPrivateKey(t *testing.T) {
-	priv, _, _ := csp.GeneratePrivateKey(testDir)
+	priv, _, _ := csp.GeneratePrivateKey(testDir, "")
 	pkFile := filepath.Join(testDir, hex.EncodeToString(priv.SKI())+"_sk")
 	assert.Equal(t, true, checkForFile(pkFile),
 		"Expected to find private key file")
@@ -81,7 +81,7 @@ func TestLoadPrivateKey_wrongEncoding(t *testing.T) {
 
 func TestGeneratePrivateKey(t *testing.T) {
 
-	priv, signer, err := csp.GeneratePrivateKey(testDir)
+	priv, signer, err := csp.GeneratePrivateKey(testDir, "")
 	assert.NoError(t, err, "Failed to generate private key")
 	assert.NotNil(t, priv, "Should have returned a bccsp.Key")
 	assert.Equal(t, true, priv.Private(), "Failed to return private key")
@@ -96,7 +96,7 @@ func TestGeneratePrivateKey(t *testing.T) {
 
 func TestGetECPublicKey(t *testing.T) {
 
-	priv, _, err := csp.GeneratePrivateKey(testDir)
+	priv, _, err := csp.GeneratePrivateKey(testDir, "")
 	assert.NoError(t, err, "Failed to generate private key")
 
 	ecPubKey, err := csp.GetECPublicKey(priv)
diff --git a/common/tools/cryptogen/main.go b/common/tools/cryptogen/main.go
index f5549f3ef..b6bf223d0 100644
--- a/common/tools/cryptogen/main.go
+++ b/common/tools/cryptogen/main.go
@@ -58,6 +58,7 @@ type NodeSpec struct {
 	StreetAddress      string   `yaml:"StreetAddress"`
 	PostalCode         string   `yaml:"PostalCode"`
 	SANS               []string `yaml:"SANS"`
+	Algorithm          string   `yaml:"Algorithm"`
 }
 
 type UsersSpec struct {
@@ -308,7 +309,7 @@ func extendPeerOrg(orgSpec OrgSpec) {
 	signCA := getCA(caDir, orgSpec, orgSpec.CA.CommonName)
 	tlsCA := getCA(tlscaDir, orgSpec, "tls"+orgSpec.CA.CommonName)
 
-	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs)
+	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs, orgSpec.CA.Algorithm)
 
 	adminUser := NodeSpec{
 		CommonName: fmt.Sprintf("%s@%s", adminBaseName, orgName),
@@ -334,7 +335,7 @@ func extendPeerOrg(orgSpec OrgSpec) {
 		users = append(users, user)
 	}
 
-	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs)
+	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs, orgSpec.CA.Algorithm)
 }
 
 func extendOrdererOrg(orgSpec OrgSpec) {
@@ -353,7 +354,7 @@ func extendOrdererOrg(orgSpec OrgSpec) {
 	signCA := getCA(caDir, orgSpec, orgSpec.CA.CommonName)
 	tlsCA := getCA(tlscaDir, orgSpec, "tls"+orgSpec.CA.CommonName)
 
-	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, false)
+	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, false, orgSpec.CA.Algorithm)
 
 	adminUser := NodeSpec{
 		CommonName: fmt.Sprintf("%s@%s", adminBaseName, orgName),
@@ -514,25 +515,29 @@ func generatePeerOrg(baseDir string, orgSpec OrgSpec) {
 	usersDir := filepath.Join(orgDir, "users")
 	adminCertsDir := filepath.Join(mspDir, "admincerts")
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province,
+		orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress,
+		orgSpec.CA.PostalCode, orgSpec.CA.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating signCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country,
+		orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress,
+		orgSpec.CA.PostalCode, orgSpec.CA.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating tlsCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
 
-	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, orgSpec.EnableNodeOUs)
+	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, orgSpec.EnableNodeOUs, orgSpec.CA.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating MSP for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
 
-	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs)
+	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs, orgSpec.CA.Algorithm)
 
 	// TODO: add ability to specify usernames
 	users := []NodeSpec{}
@@ -549,7 +554,7 @@ func generatePeerOrg(baseDir string, orgSpec OrgSpec) {
 	}
 
 	users = append(users, adminUser)
-	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs)
+	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs, orgSpec.CA.Algorithm)
 
 	// copy the admin cert to the org's MSP admincerts
 	err = copyAdminCert(usersDir, adminCertsDir, adminUser.CommonName)
@@ -596,12 +601,12 @@ func copyAdminCert(usersDir, adminCertsDir, adminUserName string) error {
 
 }
 
-func generateNodes(baseDir string, nodes []NodeSpec, signCA *ca.CA, tlsCA *ca.CA, nodeType int, nodeOUs bool) {
+func generateNodes(baseDir string, nodes []NodeSpec, signCA *ca.CA, tlsCA *ca.CA, nodeType int, nodeOUs bool, algo string) {
 
 	for _, node := range nodes {
 		nodeDir := filepath.Join(baseDir, node.CommonName)
 		if _, err := os.Stat(nodeDir); os.IsNotExist(err) {
-			err := msp.GenerateLocalMSP(nodeDir, node.CommonName, node.SANS, signCA, tlsCA, nodeType, nodeOUs)
+			err := msp.GenerateLocalMSP(nodeDir, node.CommonName, node.SANS, signCA, tlsCA, nodeType, nodeOUs, algo)
 			if err != nil {
 				fmt.Printf("Error generating local MSP for %s:\n%v\n", node, err)
 				os.Exit(1)
@@ -623,25 +628,28 @@ func generateOrdererOrg(baseDir string, orgSpec OrgSpec) {
 	usersDir := filepath.Join(orgDir, "users")
 	adminCertsDir := filepath.Join(mspDir, "admincerts")
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province,
+		orgSpec.CA.Locality,
+		orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode, orgSpec.CA.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating signCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province,
+		orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode,
+		orgSpec.CA.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating tlsCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
-
-	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, false)
+	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, false, orgSpec.CA.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating MSP for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
 
-	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, false)
+	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, false, orgSpec.CA.Algorithm)
 
 	adminUser := NodeSpec{
 		CommonName: fmt.Sprintf("%s@%s", adminBaseName, orgName),
@@ -651,7 +659,7 @@ func generateOrdererOrg(baseDir string, orgSpec OrgSpec) {
 	users := []NodeSpec{}
 	// add an admin user
 	users = append(users, adminUser)
-	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, false)
+	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, false, orgSpec.CA.Algorithm)
 
 	// copy the admin cert to the org's MSP admincerts
 	err = copyAdminCert(usersDir, adminCertsDir, adminUser.CommonName)
diff --git a/common/tools/cryptogen/msp/generator.go b/common/tools/cryptogen/msp/generator.go
index baf4f453b..0bf073cd3 100644
--- a/common/tools/cryptogen/msp/generator.go
+++ b/common/tools/cryptogen/msp/generator.go
@@ -21,7 +21,7 @@ import (
 )
 
 const (
-	CLIENT = iota
+	CLIENT  = iota
 	ORDERER
 	PEER
 )
@@ -37,7 +37,7 @@ var nodeOUMap = map[int]string{
 }
 
 func GenerateLocalMSP(baseDir, name string, sans []string, signCA *ca.CA,
-	tlsCA *ca.CA, nodeType int, nodeOUs bool) error {
+	tlsCA *ca.CA, nodeType int, nodeOUs bool, algo string) error {
 
 	// create folder structure
 	mspDir := filepath.Join(baseDir, "msp")
@@ -60,7 +60,7 @@ func GenerateLocalMSP(baseDir, name string, sans []string, signCA *ca.CA,
 	keystore := filepath.Join(mspDir, "keystore")
 
 	// generate private key
-	priv, _, err := csp.GeneratePrivateKey(keystore)
+	priv, _, err := csp.GeneratePrivateKey(keystore, algo)
 	if err != nil {
 		return err
 	}
@@ -116,7 +116,7 @@ func GenerateLocalMSP(baseDir, name string, sans []string, signCA *ca.CA,
 	*/
 
 	// generate private key
-	tlsPrivKey, _, err := csp.GeneratePrivateKey(tlsDir)
+	tlsPrivKey, _, err := csp.GeneratePrivateKey(tlsDir, algo)
 	if err != nil {
 		return err
 	}
@@ -156,7 +156,7 @@ func GenerateLocalMSP(baseDir, name string, sans []string, signCA *ca.CA,
 	return nil
 }
 
-func GenerateVerifyingMSP(baseDir string, signCA *ca.CA, tlsCA *ca.CA, nodeOUs bool) error {
+func GenerateVerifyingMSP(baseDir string, signCA *ca.CA, tlsCA *ca.CA, nodeOUs bool, algo string) error {
 
 	// create folder structure and write artifacts to proper locations
 	err := createFolderStructure(baseDir, false)
diff --git a/common/tools/cryptogen/msp/msp_test.go b/common/tools/cryptogen/msp/msp_test.go
index 67200707e..ae6da8395 100644
--- a/common/tools/cryptogen/msp/msp_test.go
+++ b/common/tools/cryptogen/msp/msp_test.go
@@ -36,7 +36,7 @@ func TestGenerateLocalMSP(t *testing.T) {
 
 	cleanup(testDir)
 
-	err := msp.GenerateLocalMSP(testDir, testName, nil, &ca.CA{}, &ca.CA{}, msp.PEER, true)
+	err := msp.GenerateLocalMSP(testDir, testName, nil, &ca.CA{}, &ca.CA{}, msp.PEER, true, "")
 	assert.Error(t, err, "Empty CA should have failed")
 
 	caDir := filepath.Join(testDir, "ca")
@@ -45,10 +45,10 @@ func TestGenerateLocalMSP(t *testing.T) {
 	tlsDir := filepath.Join(testDir, "tls")
 
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 
 	assert.NotEmpty(t, signCA.SignCert.Subject.Country, "country cannot be empty.")
@@ -65,7 +65,7 @@ func TestGenerateLocalMSP(t *testing.T) {
 	assert.Equal(t, testPostalCode, signCA.SignCert.Subject.PostalCode[0], "Failed to match postalCode")
 
 	// generate local MSP for nodeType=PEER
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.PEER, true)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.PEER, true, "")
 	assert.NoError(t, err, "Failed to generate local MSP")
 
 	// check to see that the right files were generated/saved
@@ -93,7 +93,7 @@ func TestGenerateLocalMSP(t *testing.T) {
 	}
 
 	// generate local MSP for nodeType=CLIENT
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, true)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, true, "")
 	assert.NoError(t, err, "Failed to generate local MSP")
 	//only need to check for the TLS certs
 	tlsFiles = []string{
@@ -116,10 +116,10 @@ func TestGenerateLocalMSP(t *testing.T) {
 	assert.NoError(t, err, "Error setting up local MSP")
 
 	tlsCA.Name = "test/fail"
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, true)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, true, "")
 	assert.Error(t, err, "Should have failed with CA name 'test/fail'")
 	signCA.Name = "test/fail"
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.ORDERER, true)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.ORDERER, true, "")
 	assert.Error(t, err, "Should have failed with CA name 'test/fail'")
 	t.Log(err)
 	cleanup(testDir)
@@ -132,13 +132,13 @@ func TestGenerateVerifyingMSP(t *testing.T) {
 	tlsCADir := filepath.Join(testDir, "tlsca")
 	mspDir := filepath.Join(testDir, "msp")
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 
-	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, true)
+	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, true, "")
 	assert.NoError(t, err, "Failed to generate verifying MSP")
 
 	// check to see that the right files were generated/saved
@@ -162,10 +162,10 @@ func TestGenerateVerifyingMSP(t *testing.T) {
 	assert.NoError(t, err, "Error setting up verifying MSP")
 
 	tlsCA.Name = "test/fail"
-	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, true)
+	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, true, "")
 	assert.Error(t, err, "Should have failed with CA name 'test/fail'")
 	signCA.Name = "test/fail"
-	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, true)
+	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, true, "")
 	assert.Error(t, err, "Should have failed with CA name 'test/fail'")
 	t.Log(err)
 	cleanup(testDir)
-- 
2.20.1.windows.1


From 21fc1faa26fcf9ff8b3a21df79872bc17923a486 Mon Sep 17 00:00:00 2001
From: fengjianjian <fengjj@7zhilu.com>
Date: Fri, 14 Feb 2020 20:46:26 +0800
Subject: [PATCH] add rsa support

---
 bccsp/opts.go                           | 16 ++++++++++++++++
 bccsp/sw/keyimport.go                   | 26 ++++++++++++++++++++++++++
 bccsp/sw/new.go                         |  1 +
 bccsp/sw/rsa.go                         |  8 ++++----
 bccsp/utils/keys.go                     |  7 +++++++
 common/tools/cryptogen/ca/ca_test.go    |  8 ++++----
 common/tools/cryptogen/ca/generator.go  | 17 ++++++++---------
 common/tools/cryptogen/csp/csp.go       | 15 ++++++++++-----
 common/tools/cryptogen/csp/csp_test.go  | 14 +++++++-------
 common/tools/cryptogen/main.go          | 27 ++++++++++++++-------------
 common/tools/cryptogen/msp/generator.go | 12 ++++++------
 common/tools/cryptogen/msp/msp_test.go  | 18 +++++++++---------
 12 files changed, 112 insertions(+), 57 deletions(-)

diff --git a/bccsp/opts.go b/bccsp/opts.go
index e81e50c..4540131 100644
--- a/bccsp/opts.go
+++ b/bccsp/opts.go
@@ -305,6 +305,22 @@ func (opts *RSAGoPublicKeyImportOpts) Ephemeral() bool {
 	return opts.Temporary
 }
 
+// RSA2048PrivateKeyImportOpts contains options for RSA2048 secret key importation in DER format
+type RSA2048PrivateKeyImportOpts struct {
+	Temporary bool
+}
+
+// Algorithm returns the key importation algorithm identifier (to be used).
+func (opts *RSA2048PrivateKeyImportOpts) Algorithm() string {
+	return RSA2048
+}
+
+// Ephemeral returns true if the key to generate has to be ephemeral,
+// false otherwise.
+func (opts *RSA2048PrivateKeyImportOpts) Ephemeral() bool {
+	return opts.Temporary
+}
+
 // X509PublicKeyImportOpts contains options for importing public keys from an x509 certificate
 type X509PublicKeyImportOpts struct {
 	Temporary bool
diff --git a/bccsp/sw/keyimport.go b/bccsp/sw/keyimport.go
index b2003fb..c70c796 100644
--- a/bccsp/sw/keyimport.go
+++ b/bccsp/sw/keyimport.go
@@ -134,6 +134,32 @@ func (*rsaGoPublicKeyImportOptsKeyImporter) KeyImport(raw interface{}, opts bccs
 	return &rsaPublicKey{lowLevelKey}, nil
 }
 
+type rsaPrivatekeyImportOptsKeyImporter struct {
+}
+
+func (*rsaPrivatekeyImportOptsKeyImporter) KeyImport(raw interface{}, opts bccsp.KeyImportOpts) (bccsp.Key, error) {
+	der, ok := raw.([]byte)
+	if !ok {
+		return nil, errors.New("[RSA2048PrivateKeyImportOpts] Invalid raw material. Expected byte array.")
+	}
+
+	if len(der) == 0 {
+		return nil, errors.New("[RSA2048PrivateKeyImportOpts] Invalid raw. It must not be nil.")
+	}
+
+	lowLevelKey, err := utils.DERToPrivateKey(der)
+	if err != nil {
+		return nil, fmt.Errorf("Failed converting PKIX to rsa public key [%s]", err)
+	}
+
+	rsaSK, ok := lowLevelKey.(*rsa.PrivateKey)
+	if !ok {
+		return nil, errors.New("Failed casting to rsa private key. Invalid raw material.")
+	}
+	return &rsaPrivateKey{rsaSK}, nil
+}
+
+
 type x509PublicKeyImportOptsKeyImporter struct {
 	bccsp *CSP
 }
diff --git a/bccsp/sw/new.go b/bccsp/sw/new.go
index 9959fab..b82b3ce 100644
--- a/bccsp/sw/new.go
+++ b/bccsp/sw/new.go
@@ -101,6 +101,7 @@ func NewWithParams(securityLevel int, hashFamily string, keyStore bccsp.KeyStore
 	swbccsp.AddWrapper(reflect.TypeOf(&bccsp.ECDSAGoPublicKeyImportOpts{}), &ecdsaGoPublicKeyImportOptsKeyImporter{})
 	swbccsp.AddWrapper(reflect.TypeOf(&bccsp.RSAGoPublicKeyImportOpts{}), &rsaGoPublicKeyImportOptsKeyImporter{})
 	swbccsp.AddWrapper(reflect.TypeOf(&bccsp.X509PublicKeyImportOpts{}), &x509PublicKeyImportOptsKeyImporter{bccsp: swbccsp})
+	swbccsp.AddWrapper(reflect.TypeOf(&bccsp.RSA2048PrivateKeyImportOpts{}), &rsaPrivatekeyImportOptsKeyImporter{})
 
 	return swbccsp, nil
 }
diff --git a/bccsp/sw/rsa.go b/bccsp/sw/rsa.go
index 375990d..016b0bc 100644
--- a/bccsp/sw/rsa.go
+++ b/bccsp/sw/rsa.go
@@ -17,9 +17,9 @@ limitations under the License.
 package sw
 
 import (
+	"crypto"
 	"crypto/rand"
 	"crypto/rsa"
-	"errors"
 	"fmt"
 
 	"github.com/hyperledger/fabric/bccsp"
@@ -29,7 +29,7 @@ type rsaSigner struct{}
 
 func (s *rsaSigner) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) ([]byte, error) {
 	if opts == nil {
-		return nil, errors.New("Invalid options. Must be different from nil.")
+		opts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: crypto.SHA256}
 	}
 
 	return k.(*rsaPrivateKey).privKey.Sign(rand.Reader, digest, opts)
@@ -39,7 +39,7 @@ type rsaPrivateKeyVerifier struct{}
 
 func (v *rsaPrivateKeyVerifier) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (bool, error) {
 	if opts == nil {
-		return false, errors.New("Invalid options. It must not be nil.")
+		opts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: crypto.SHA256}
 	}
 	switch opts.(type) {
 	case *rsa.PSSOptions:
@@ -57,7 +57,7 @@ type rsaPublicKeyKeyVerifier struct{}
 
 func (v *rsaPublicKeyKeyVerifier) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (bool, error) {
 	if opts == nil {
-		return false, errors.New("Invalid options. It must not be nil.")
+		opts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: crypto.SHA256}
 	}
 	switch opts.(type) {
 	case *rsa.PSSOptions:
diff --git a/bccsp/utils/keys.go b/bccsp/utils/keys.go
index ee2d928..428e227 100644
--- a/bccsp/utils/keys.go
+++ b/bccsp/utils/keys.go
@@ -74,6 +74,13 @@ func PrivateKeyToDER(privateKey *ecdsa.PrivateKey) ([]byte, error) {
 	return x509.MarshalECPrivateKey(privateKey)
 }
 
+func RsaPrivateKeyToDER(privateKey *rsa.PrivateKey) ([]byte, error) {
+	if privateKey == nil {
+		return nil, errors.New("Invalid rsa private key. It must be different from nil.")
+	}
+	return x509.MarshalPKCS1PrivateKey(privateKey), nil
+}
+
 // PrivateKeyToPEM converts the private key to PEM format.
 // EC private keys are converted to PKCS#8 format.
 // RSA private keys are converted to PKCS#1 format.
diff --git a/common/tools/cryptogen/ca/ca_test.go b/common/tools/cryptogen/ca/ca_test.go
index 95fc39b..01720fc 100644
--- a/common/tools/cryptogen/ca/ca_test.go
+++ b/common/tools/cryptogen/ca/ca_test.go
@@ -40,11 +40,11 @@ func TestLoadCertificateECDSA(t *testing.T) {
 	caDir := filepath.Join(testDir, "ca")
 	certDir := filepath.Join(testDir, "certs")
 	// generate private key
-	priv, _, err := csp.GeneratePrivateKey(certDir)
+	priv, _, err := csp.GeneratePrivateKey(certDir, "")
 	assert.NoError(t, err, "Failed to generate signed certificate")
 
 	// get EC public key
-	ecPubKey, err := csp.GetECPublicKey(priv)
+	ecPubKey, err := csp.GetPublicKey(priv)
 	assert.NoError(t, err, "Failed to generate signed certificate")
 	assert.NotNil(t, ecPubKey, "Failed to generate signed certificate")
 
@@ -106,11 +106,11 @@ func TestGenerateSignCertificate(t *testing.T) {
 	caDir := filepath.Join(testDir, "ca")
 	certDir := filepath.Join(testDir, "certs")
 	// generate private key
-	priv, _, err := csp.GeneratePrivateKey(certDir)
+	priv, _, err := csp.GeneratePrivateKey(certDir, "")
 	assert.NoError(t, err, "Failed to generate signed certificate")
 
 	// get EC public key
-	ecPubKey, err := csp.GetECPublicKey(priv)
+	ecPubKey, err := csp.GetPublicKey(priv)
 	assert.NoError(t, err, "Failed to generate signed certificate")
 	assert.NotNil(t, ecPubKey, "Failed to generate signed certificate")
 
diff --git a/common/tools/cryptogen/ca/generator.go b/common/tools/cryptogen/ca/generator.go
index 7651ac4..14ba65c 100644
--- a/common/tools/cryptogen/ca/generator.go
+++ b/common/tools/cryptogen/ca/generator.go
@@ -7,7 +7,6 @@ package ca
 
 import (
 	"crypto"
-	"crypto/ecdsa"
 	"crypto/rand"
 	"crypto/x509"
 	"crypto/x509/pkix"
@@ -39,18 +38,18 @@ type CA struct {
 
 // NewCA creates an instance of CA and saves the signing key pair in
 // baseDir/name
-func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddress, postalCode string) (*CA, error) {
+func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddress, postalCode string, algo string) (*CA, error) {
 
 	var response error
 	var ca *CA
 
 	err := os.MkdirAll(baseDir, 0755)
 	if err == nil {
-		priv, signer, err := csp.GeneratePrivateKey(baseDir)
+		priv, signer, err := csp.GeneratePrivateKey(baseDir, algo)
 		response = err
 		if err == nil {
 			// get public signing certificate
-			ecPubKey, err := csp.GetECPublicKey(priv)
+			ecPubKey, err := csp.GetPublicKey(priv)
 			response = err
 			if err == nil {
 				template := x509Template()
@@ -72,7 +71,7 @@ func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddre
 				template.Subject = subject
 				template.SubjectKeyId = priv.SKI()
 
-				x509Cert, err := genCertificateECDSA(baseDir, name, &template, &template,
+				x509Cert, err := genCertificate(baseDir, name, &template, &template,
 					ecPubKey, signer)
 				response = err
 				if err == nil {
@@ -96,7 +95,7 @@ func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddre
 
 // SignCertificate creates a signed certificate based on a built-in template
 // and saves it in baseDir/name
-func (ca *CA) SignCertificate(baseDir, name string, ous, sans []string, pub *ecdsa.PublicKey,
+func (ca *CA) SignCertificate(baseDir, name string, ous, sans []string, pub interface{},
 	ku x509.KeyUsage, eku []x509.ExtKeyUsage) (*x509.Certificate, error) {
 
 	template := x509Template()
@@ -120,7 +119,7 @@ func (ca *CA) SignCertificate(baseDir, name string, ous, sans []string, pub *ecd
 		}
 	}
 
-	cert, err := genCertificateECDSA(baseDir, name, &template, ca.SignCert,
+	cert, err := genCertificate(baseDir, name, &template, ca.SignCert,
 		pub, ca.Signer)
 
 	if err != nil {
@@ -187,8 +186,8 @@ func x509Template() x509.Certificate {
 
 }
 
-// generate a signed X509 certificate using ECDSA
-func genCertificateECDSA(baseDir, name string, template, parent *x509.Certificate, pub *ecdsa.PublicKey,
+// generate a signed X509 certificate using ECDSA or RSA2048
+func genCertificate(baseDir, name string, template, parent *x509.Certificate, pub interface{},
 	priv interface{}) (*x509.Certificate, error) {
 
 	//create the x509 public cert
diff --git a/common/tools/cryptogen/csp/csp.go b/common/tools/cryptogen/csp/csp.go
index 40cfaea..f120f85 100644
--- a/common/tools/cryptogen/csp/csp.go
+++ b/common/tools/cryptogen/csp/csp.go
@@ -7,7 +7,6 @@ package csp
 
 import (
 	"crypto"
-	"crypto/ecdsa"
 	"crypto/x509"
 	"encoding/pem"
 	"io/ioutil"
@@ -79,7 +78,7 @@ func LoadPrivateKey(keystorePath string) (bccsp.Key, crypto.Signer, error) {
 }
 
 // GeneratePrivateKey creates a private key and stores it in keystorePath
-func GeneratePrivateKey(keystorePath string) (bccsp.Key,
+func GeneratePrivateKey(keystorePath string, algo string) (bccsp.Key,
 	crypto.Signer, error) {
 
 	var err error
@@ -98,6 +97,12 @@ func GeneratePrivateKey(keystorePath string) (bccsp.Key,
 		},
 	}
 	csp, err := factory.GetBCCSPFromOpts(opts)
+	var opt bccsp.KeyGenOpts
+	opt = &bccsp.ECDSAP256KeyGenOpts{Temporary: false}
+	if strings.ToUpper(algo) == bccsp.RSA {
+		opt = &bccsp.RSAKeyGenOpts{Temporary: false}
+	}
+	priv, err = csp.KeyGen(opt)
 	if err == nil {
 		// generate a key
 		priv, err = csp.KeyGen(&bccsp.ECDSAP256KeyGenOpts{Temporary: false})
@@ -109,7 +114,7 @@ func GeneratePrivateKey(keystorePath string) (bccsp.Key,
 	return priv, s, err
 }
 
-func GetECPublicKey(priv bccsp.Key) (*ecdsa.PublicKey, error) {
+func GetPublicKey(priv bccsp.Key) (interface{}, error) {
 
 	// get the public key
 	pubKey, err := priv.PublicKey()
@@ -122,9 +127,9 @@ func GetECPublicKey(priv bccsp.Key) (*ecdsa.PublicKey, error) {
 		return nil, err
 	}
 	// unmarshal using pkix
-	ecPubKey, err := x509.ParsePKIXPublicKey(pubKeyBytes)
+	x509PubKey, err := x509.ParsePKIXPublicKey(pubKeyBytes)
 	if err != nil {
 		return nil, err
 	}
-	return ecPubKey.(*ecdsa.PublicKey), nil
+	return x509PubKey, nil
 }
diff --git a/common/tools/cryptogen/csp/csp_test.go b/common/tools/cryptogen/csp/csp_test.go
index f2210e1..8d8f2f6 100644
--- a/common/tools/cryptogen/csp/csp_test.go
+++ b/common/tools/cryptogen/csp/csp_test.go
@@ -48,7 +48,7 @@ func (mk *mockKey) Private() bool { return false }
 var testDir = filepath.Join(os.TempDir(), "csp-test")
 
 func TestLoadPrivateKey(t *testing.T) {
-	priv, _, _ := csp.GeneratePrivateKey(testDir)
+	priv, _, _ := csp.GeneratePrivateKey(testDir, "")
 	pkFile := filepath.Join(testDir, hex.EncodeToString(priv.SKI())+"_sk")
 	assert.Equal(t, true, checkForFile(pkFile),
 		"Expected to find private key file")
@@ -81,7 +81,7 @@ func TestLoadPrivateKey_wrongEncoding(t *testing.T) {
 
 func TestGeneratePrivateKey(t *testing.T) {
 
-	priv, signer, err := csp.GeneratePrivateKey(testDir)
+	priv, signer, err := csp.GeneratePrivateKey(testDir, "")
 	assert.NoError(t, err, "Failed to generate private key")
 	assert.NotNil(t, priv, "Should have returned a bccsp.Key")
 	assert.Equal(t, true, priv.Private(), "Failed to return private key")
@@ -96,10 +96,10 @@ func TestGeneratePrivateKey(t *testing.T) {
 
 func TestGetECPublicKey(t *testing.T) {
 
-	priv, _, err := csp.GeneratePrivateKey(testDir)
+	priv, _, err := csp.GeneratePrivateKey(testDir, "")
 	assert.NoError(t, err, "Failed to generate private key")
 
-	ecPubKey, err := csp.GetECPublicKey(priv)
+	ecPubKey, err := csp.GetPublicKey(priv)
 	assert.NoError(t, err, "Failed to get public key from private key")
 	assert.IsType(t, &ecdsa.PublicKey{}, ecPubKey,
 		"Failed to return an ecdsa.PublicKey")
@@ -110,7 +110,7 @@ func TestGetECPublicKey(t *testing.T) {
 		bytesErr:  nil,
 		pubKey:    &mockKey{},
 	}
-	_, err = csp.GetECPublicKey(priv)
+	_, err = csp.GetPublicKey(priv)
 	assert.Error(t, err, "Expected an error with a invalid pubKey bytes")
 	priv = &mockKey{
 		pubKeyErr: nil,
@@ -119,14 +119,14 @@ func TestGetECPublicKey(t *testing.T) {
 			bytesErr: errors.New("bytesErr"),
 		},
 	}
-	_, err = csp.GetECPublicKey(priv)
+	_, err = csp.GetPublicKey(priv)
 	assert.EqualError(t, err, "bytesErr", "Expected bytesErr")
 	priv = &mockKey{
 		pubKeyErr: errors.New("pubKeyErr"),
 		bytesErr:  nil,
 		pubKey:    &mockKey{},
 	}
-	_, err = csp.GetECPublicKey(priv)
+	_, err = csp.GetPublicKey(priv)
 	assert.EqualError(t, err, "pubKeyErr", "Expected pubKeyErr")
 
 	cleanup(testDir)
diff --git a/common/tools/cryptogen/main.go b/common/tools/cryptogen/main.go
index a1b5c41..cff0329 100644
--- a/common/tools/cryptogen/main.go
+++ b/common/tools/cryptogen/main.go
@@ -73,6 +73,7 @@ type OrgSpec struct {
 	Template      NodeTemplate `yaml:"Template"`
 	Specs         []NodeSpec   `yaml:"Specs"`
 	Users         UsersSpec    `yaml:"Users"`
+	Algorithm     string       `yaml:"Algorithm"`
 }
 
 type Config struct {
@@ -310,7 +311,7 @@ func extendPeerOrg(orgSpec OrgSpec) {
 	signCA := getCA(caDir, orgSpec, orgSpec.CA.CommonName)
 	tlsCA := getCA(tlscaDir, orgSpec, "tls"+orgSpec.CA.CommonName)
 
-	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs)
+	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs, orgSpec.Algorithm)
 
 	adminUser := NodeSpec{
 		CommonName: fmt.Sprintf("%s@%s", adminBaseName, orgName),
@@ -339,7 +340,7 @@ func extendPeerOrg(orgSpec OrgSpec) {
 		users = append(users, user)
 	}
 
-	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs)
+	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs, orgSpec.Algorithm)
 }
 
 func extendOrdererOrg(orgSpec OrgSpec) {
@@ -358,7 +359,7 @@ func extendOrdererOrg(orgSpec OrgSpec) {
 	signCA := getCA(caDir, orgSpec, orgSpec.CA.CommonName)
 	tlsCA := getCA(tlscaDir, orgSpec, "tls"+orgSpec.CA.CommonName)
 
-	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, orgSpec.EnableNodeOUs)
+	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, orgSpec.EnableNodeOUs, orgSpec.Algorithm)
 
 	adminUser := NodeSpec{
 		CommonName: fmt.Sprintf("%s@%s", adminBaseName, orgName),
@@ -522,13 +523,13 @@ func generatePeerOrg(baseDir string, orgSpec OrgSpec) {
 	usersDir := filepath.Join(orgDir, "users")
 	adminCertsDir := filepath.Join(mspDir, "admincerts")
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode, orgSpec.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating signCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode, orgSpec.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating tlsCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
@@ -540,7 +541,7 @@ func generatePeerOrg(baseDir string, orgSpec OrgSpec) {
 		os.Exit(1)
 	}
 
-	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs)
+	generateNodes(peersDir, orgSpec.Specs, signCA, tlsCA, msp.PEER, orgSpec.EnableNodeOUs, orgSpec.Algorithm)
 
 	// TODO: add ability to specify usernames
 	users := []NodeSpec{}
@@ -558,7 +559,7 @@ func generatePeerOrg(baseDir string, orgSpec OrgSpec) {
 	}
 
 	users = append(users, adminUser)
-	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs)
+	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs, orgSpec.Algorithm)
 
 	// copy the admin cert to the org's MSP admincerts
 	if !orgSpec.EnableNodeOUs {
@@ -609,7 +610,7 @@ func copyAdminCert(usersDir, adminCertsDir, adminUserName string) error {
 	return nil
 }
 
-func generateNodes(baseDir string, nodes []NodeSpec, signCA *ca.CA, tlsCA *ca.CA, nodeType int, nodeOUs bool) {
+func generateNodes(baseDir string, nodes []NodeSpec, signCA *ca.CA, tlsCA *ca.CA, nodeType int, nodeOUs bool, algo string) {
 
 	for _, node := range nodes {
 		nodeDir := filepath.Join(baseDir, node.CommonName)
@@ -618,7 +619,7 @@ func generateNodes(baseDir string, nodes []NodeSpec, signCA *ca.CA, tlsCA *ca.CA
 			if node.isAdmin && nodeOUs {
 				currentNodeType = msp.ADMIN
 			}
-			err := msp.GenerateLocalMSP(nodeDir, node.CommonName, node.SANS, signCA, tlsCA, currentNodeType, nodeOUs)
+			err := msp.GenerateLocalMSP(nodeDir, node.CommonName, node.SANS, signCA, tlsCA, currentNodeType, nodeOUs, algo)
 			if err != nil {
 				fmt.Printf("Error generating local MSP for %v:\n%v\n", node, err)
 				os.Exit(1)
@@ -640,13 +641,13 @@ func generateOrdererOrg(baseDir string, orgSpec OrgSpec) {
 	usersDir := filepath.Join(orgDir, "users")
 	adminCertsDir := filepath.Join(mspDir, "admincerts")
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	signCA, err := ca.NewCA(caDir, orgName, orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode, orgSpec.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating signCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
 	}
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, orgName, "tls"+orgSpec.CA.CommonName, orgSpec.CA.Country, orgSpec.CA.Province, orgSpec.CA.Locality, orgSpec.CA.OrganizationalUnit, orgSpec.CA.StreetAddress, orgSpec.CA.PostalCode, orgSpec.Algorithm)
 	if err != nil {
 		fmt.Printf("Error generating tlsCA for org %s:\n%v\n", orgName, err)
 		os.Exit(1)
@@ -658,7 +659,7 @@ func generateOrdererOrg(baseDir string, orgSpec OrgSpec) {
 		os.Exit(1)
 	}
 
-	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, orgSpec.EnableNodeOUs)
+	generateNodes(orderersDir, orgSpec.Specs, signCA, tlsCA, msp.ORDERER, orgSpec.EnableNodeOUs, orgSpec.Algorithm)
 
 	adminUser := NodeSpec{
 		isAdmin:    true,
@@ -669,7 +670,7 @@ func generateOrdererOrg(baseDir string, orgSpec OrgSpec) {
 	users := []NodeSpec{}
 	// add an admin user
 	users = append(users, adminUser)
-	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs)
+	generateNodes(usersDir, users, signCA, tlsCA, msp.CLIENT, orgSpec.EnableNodeOUs, orgSpec.Algorithm)
 
 	// copy the admin cert to the org's MSP admincerts
 	if !orgSpec.EnableNodeOUs {
diff --git a/common/tools/cryptogen/msp/generator.go b/common/tools/cryptogen/msp/generator.go
index eb9c9c7..db4e234 100644
--- a/common/tools/cryptogen/msp/generator.go
+++ b/common/tools/cryptogen/msp/generator.go
@@ -42,7 +42,7 @@ var nodeOUMap = map[int]string{
 }
 
 func GenerateLocalMSP(baseDir, name string, sans []string, signCA *ca.CA,
-	tlsCA *ca.CA, nodeType int, nodeOUs bool) error {
+	tlsCA *ca.CA, nodeType int, nodeOUs bool, algo string) error {
 
 	// create folder structure
 	mspDir := filepath.Join(baseDir, "msp")
@@ -65,13 +65,13 @@ func GenerateLocalMSP(baseDir, name string, sans []string, signCA *ca.CA,
 	keystore := filepath.Join(mspDir, "keystore")
 
 	// generate private key
-	priv, _, err := csp.GeneratePrivateKey(keystore)
+	priv, _, err := csp.GeneratePrivateKey(keystore, algo)
 	if err != nil {
 		return err
 	}
 
 	// get public key
-	ecPubKey, err := csp.GetECPublicKey(priv)
+	ecPubKey, err := csp.GetPublicKey(priv)
 	if err != nil {
 		return err
 	}
@@ -124,12 +124,12 @@ func GenerateLocalMSP(baseDir, name string, sans []string, signCA *ca.CA,
 	*/
 
 	// generate private key
-	tlsPrivKey, _, err := csp.GeneratePrivateKey(tlsDir)
+	tlsPrivKey, _, err := csp.GeneratePrivateKey(tlsDir, algo)
 	if err != nil {
 		return err
 	}
 	// get public key
-	tlsPubKey, err := csp.GetECPublicKey(tlsPrivKey)
+	tlsPubKey, err := csp.GetPublicKey(tlsPrivKey)
 	if err != nil {
 		return err
 	}
@@ -198,7 +198,7 @@ func GenerateVerifyingMSP(baseDir string, signCA *ca.CA, tlsCA *ca.CA, nodeOUs b
 	factory.InitFactories(nil)
 	bcsp := factory.GetDefault()
 	priv, err := bcsp.KeyGen(&bccsp.ECDSAP256KeyGenOpts{Temporary: true})
-	ecPubKey, err := csp.GetECPublicKey(priv)
+	ecPubKey, err := csp.GetPublicKey(priv)
 	if err != nil {
 		return err
 	}
diff --git a/common/tools/cryptogen/msp/msp_test.go b/common/tools/cryptogen/msp/msp_test.go
index 1e29c59..15ca4f3 100644
--- a/common/tools/cryptogen/msp/msp_test.go
+++ b/common/tools/cryptogen/msp/msp_test.go
@@ -35,7 +35,7 @@ var testDir = filepath.Join(os.TempDir(), "msp-test")
 func testGenerateLocalMSP(t *testing.T, nodeOUs bool) {
 	cleanup(testDir)
 
-	err := msp.GenerateLocalMSP(testDir, testName, nil, &ca.CA{}, &ca.CA{}, msp.PEER, nodeOUs)
+	err := msp.GenerateLocalMSP(testDir, testName, nil, &ca.CA{}, &ca.CA{}, msp.PEER, nodeOUs, "")
 	assert.Error(t, err, "Empty CA should have failed")
 
 	caDir := filepath.Join(testDir, "ca")
@@ -44,10 +44,10 @@ func testGenerateLocalMSP(t *testing.T, nodeOUs bool) {
 	tlsDir := filepath.Join(testDir, "tls")
 
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 
 	assert.NotEmpty(t, signCA.SignCert.Subject.Country, "country cannot be empty.")
@@ -64,7 +64,7 @@ func testGenerateLocalMSP(t *testing.T, nodeOUs bool) {
 	assert.Equal(t, testPostalCode, signCA.SignCert.Subject.PostalCode[0], "Failed to match postalCode")
 
 	// generate local MSP for nodeType=PEER
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.PEER, nodeOUs)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.PEER, nodeOUs, "")
 	assert.NoError(t, err, "Failed to generate local MSP")
 
 	// check to see that the right files were generated/saved
@@ -96,7 +96,7 @@ func testGenerateLocalMSP(t *testing.T, nodeOUs bool) {
 	}
 
 	// generate local MSP for nodeType=CLIENT
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, nodeOUs)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, nodeOUs, "")
 	assert.NoError(t, err, "Failed to generate local MSP")
 	// check all
 	for _, file := range mspFiles {
@@ -118,10 +118,10 @@ func testGenerateLocalMSP(t *testing.T, nodeOUs bool) {
 	assert.NoError(t, err, "Error setting up local MSP")
 
 	tlsCA.Name = "test/fail"
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, nodeOUs)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.CLIENT, nodeOUs, "")
 	assert.Error(t, err, "Should have failed with CA name 'test/fail'")
 	signCA.Name = "test/fail"
-	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.ORDERER, nodeOUs)
+	err = msp.GenerateLocalMSP(testDir, testName, nil, signCA, tlsCA, msp.ORDERER, nodeOUs, "")
 	assert.Error(t, err, "Should have failed with CA name 'test/fail'")
 	t.Log(err)
 	cleanup(testDir)
@@ -140,10 +140,10 @@ func testGenerateVerifyingMSP(t *testing.T, nodeOUs bool) {
 	tlsCADir := filepath.Join(testDir, "tlsca")
 	mspDir := filepath.Join(testDir, "msp")
 	// generate signing CA
-	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	signCA, err := ca.NewCA(caDir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 	// generate TLS CA
-	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode)
+	tlsCA, err := ca.NewCA(tlsCADir, testCAOrg, testCAName, testCountry, testProvince, testLocality, testOrganizationalUnit, testStreetAddress, testPostalCode, "")
 	assert.NoError(t, err, "Error generating CA")
 
 	err = msp.GenerateVerifyingMSP(mspDir, signCA, tlsCA, nodeOUs)
-- 
2.7.4

